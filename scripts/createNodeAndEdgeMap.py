# Author: Vivek Sriram
# Last revised: 06/23/2021
# ------------------------------------------------
# Function: Given the intermediate file that corresponds
#			to associated SNPs for a set of phenotypes,
#			this script will create the corresponding
#			edge and node maps. Given user input for
#			MAF and/or p-value threshold, the script
#			will filter the data correspondingly.

# Import statements
import csv
import argparse
import ast

# Read in user arguments
parser = argparse.ArgumentParser(description='Take in user input for creation of node and edge maps for Gephi.')
parser.add_argument('--phenotypesnpmap-input', dest='phenotypesnpmapin', default = None, metavar='phenotype-snp map input file', help='Filepath for phenotype-snp map input file (tsv)')
parser.add_argument('--diseasecategory-input', dest='diseasecategoryin', default = None, metavar='node map input file', help='Filepath for disease category input file (tsv)')

parser.add_argument('--edgemap-output', dest='edgemapout', default = "", metavar='edge map output file', help='Filepath for edge map output file (tsv)')
parser.add_argument('--nodemap-output', dest='nodemapout', default = "", metavar='node map output file', help='Filepath for node map output file (tsv)')

parser.add_argument('--maf-threshold', dest='mafthresh', default = -1, metavar = 'MAF threshold', help='Threshold for minor allele frequency for filtration')
parser.add_argument('--pvalue-threshold', dest='pvalthresh', default = -1, metavar = 'p-value threshold', help='Threshold for significance of association between SNP and phenotype')

parser.add_argument('--ld-file', dest='ldfile', metavar = 'ld-file for pruning', help = 'Linkage disequilibrium file generated using plink --show-tags. Custom file will also work as long as the header has "SNP" and "TAGS". File should be space seperated with TAGS seperated by "|"')

args = parser.parse_args()

# Example usage:
# python createNodeAndEdgeMap.py 
# --phenotypesnpmap-input "/Users/viveksrm/Desktop/intermediateNodeMap.csv" 
# --diseasecategory-input "/Users/viveksrm/Desktop/diseaseCategoryMappings.csv"
# --edgemap-output "/Users/viveksrm/Desktop/trialEdgeMap.csv" 
# --nodemap-output "/Users/viveksrm/Desktop/trialNodeMap.csv" 
# --maf-threshold "0.05" 
# --pvalue-threshold "1e-5" 


phenotypeSnpMapPath = args.phenotypesnpmapin

diseaseCategoryInput = args.diseasecategoryin
nodeMapOutputPath = args.nodemapout
edgeMapOutputPath = args.edgemapout

mafThreshold = args.mafthresh
pValueThreshold = args.pvalthresh

ldFile = args.ldfile


# Given a SNP and its p-value and MAF, check if it passes the required thresholds
def snpPassesFilter(snpInfo, mafFilter, pvalFilter):
	if(pvalFilter != -1):
		pval = snpInfo[1]
	if(mafFilter != -1):
		maf = snpInfo[2]

	if(mafFilter == -1 and pvalFilter == -1):
		return True

	if(mafFilter == -1):
		if(float(pval) < float(pvalFilter)):
			return True

	if(pvalFilter == -1):
		if(float(maf) > float(mafFilter)):
			return True
	
	if(float(pval) < float(pvalFilter) and float(maf) > float(mafFilter)):
		return True

	return False


def updatePhenotypeSNPMapFromData(phenotypeSnpMapFilePath, mafThreshold, pValueThreshold):
	file = open(phenotypeSnpMapFilePath, 'r')
	fileLines = file.readlines()[1:]

	filteredPhenotypeSnpMap = {}
	for line in fileLines:
		lineStripped = line.strip()
		lineAsArray = lineStripped.split("\t")

		phenotype = lineAsArray[0]
		allSnps = lineAsArray[1]
		allSnpsAsList = ast.literal_eval(allSnps)
		
		for snpInfo in allSnpsAsList:
			if(snpPassesFilter(snpInfo, mafThreshold, pValueThreshold)):
				if(phenotype not in filteredPhenotypeSnpMap):
					filteredPhenotypeSnpMap[phenotype] = []
				# Add SNP ID and p-value if p-values are involved
				if(pValueThreshold != -1):
					filteredPhenotypeSnpMap[phenotype].append([snpInfo[0], snpInfo[1]])
					#filteredPhenotypeSnpMap[phenotype].append(snpInfo[0])

				# Add just the SNP ID to our list if p-values aren't invovled
				else:
					filteredPhenotypeSnpMap[phenotype].append([snpInfo[0]])

	return filteredPhenotypeSnpMap


# Parse ld file generated by plink --show-tags and create a map with snpid as key and list of snps in ld as value
def parseLdFile(file):
	snpLdsetMap = {}
	with open(file) as inf:
		header = next(inf)
		header = header.strip()
		header = header.split()
		snpIndex = header.index("SNP")
		tagIndex = header.index("TAGS")
		for line in inf:
			line = line.strip()
			line = line.split()
			snpLdsetMap[line[snpIndex]] = line[tagIndex].split('|')
	return(snpLdsetMap)


def getLdPrunedCount(snpLdsetMap, snpList):
	if not snpLdsetMap:
		return(len(snpList))
	count = 0
	ldSet = set()
	for snp in snpList:
		if snp in snpLdsetMap:
			if snp not in ldSet:
				count += 1
			ldSet.update(snpLdsetMap[snp])
		else:
			count += 1
		ldSet.add(snp)
	return(count)


phenotypeSnpMap_filtered = updatePhenotypeSNPMapFromData(phenotypeSnpMapPath, mafThreshold, pValueThreshold)

print("Created filtered phenotype map")

if(pValueThreshold != -1):
	# Sort all the tuple lists by phenotype at the end
	phenotypeSnpMap_sorted = {}
	for key in phenotypeSnpMap_filtered:
		print(key)
		snpsForThisPhenotype = phenotypeSnpMap_filtered[key]
		# Sort the list by p-value (i.e., by the second element of each tuple)
		print(snpsForThisPhenotype)

		snpsForThisPhenotype.sort(key = lambda x: float(x[1]), reverse = False)
		# Update the list in our map
		phenotypeSnpMap_sorted[key] = snpsForThisPhenotype
else:
	phenotypeSnpMap_sorted = phenotypeSnpMap_filtered




# If we want to create a node map file
print("Creating node map...")

# If the user has provided a disease category mapping, make use of it
diseaseCategoryMap = {}
if(diseaseCategoryInput != None):

	diseaseCategoryFile = open(diseaseCategoryInput, 'r')
	fileLines = diseaseCategoryFile.readlines()[1:]

	filteredPhenotypeSnpMap = {}
	for line in fileLines:
		lineStripped = line.strip()
		lineAsArray = lineStripped.split("\t")
		if(len(lineAsArray) != 2):
			sys.exit('ERROR: Disease category input file is not of the appropriate format. Make sure that the file is a tab separated file with 2 columns, where the first column is the phenotype and the second column is the categorical variable used for coloring the network.')

		currentPhenotypeID = lineAsArray[0]
		currentPhenotypeCategory = lineAsArray[1]

		diseaseCategoryMap[currentPhenotypeID] = currentPhenotypeCategory


with open(nodeMapOutputPath, 'w') as outf:
	nodeMapOutput = csv.writer(outf, delimiter = '\t')

	print("Initializing a new node map")
	header = ['Id'] + ['associatedSNPs'] + ['numAssociatedSNPs']
	if(diseaseCategoryInput != None):
		header = header + ['category']
	nodeMapOutput.writerow(header)

	# If p-value is involved, iterate over key/value pairs in List
	if(len(phenotypeSnpMap_sorted) > 0):
		for key, value in phenotypeSnpMap_sorted.items():
			if(pValueThreshold != -1):
				value = [item[0] for item in value]

			row = [str(key)] + [str(list(value))] + [str(len(list(value)))]
			# If we have the disease/category map, incorporate it
			if(diseaseCategoryInput != None):
				currentDiseaseCategory = None
				if(str(key) in diseaseCategoryMap.keys()):
					currentDiseaseCategory = diseaseCategoryMap[str(key)]
				row = row + [str(currentDiseaseCategory)]

			nodeMapOutput.writerow(row)
			print("Processed phenotype " + key + " for node map")
print("Finished creating node map.")




print("Creating edge map...")
snpLdsetMap = None
if ldFile:
	snpLdsetMap = parseLdFile(ldFile)

# Write to an output file that will include all pairs of phenotypes and their shared SNPs
with open(edgeMapOutputPath, "w") as edgeMapOutput:
	edgeMapOutput.write("Source\tTarget\tWeight\tlistOfSharedSNPs\n")
	diseasePairsAlreadySeen = set()

	# Do a nested for loop that will get the intersection of our lists for each pair of nodes
	i = 0
	for key1, value1 in phenotypeSnpMap_sorted.items():
		i = i+1
		for key2, value2 in phenotypeSnpMap_sorted.items():
			# If we've already seen 
			diseasePairV1 = key1+"_"+key2
			diseasePairV2 = key2+"_"+key1

			if((key1 != key2) and (diseasePairV1 not in diseasePairsAlreadySeen) and (diseasePairV2 not in diseasePairsAlreadySeen)):
				diseasePairsAlreadySeen.add(diseasePairV1)
				diseasePairsAlreadySeen.add(diseasePairV2)

				# Get the intersection of SNPs for the two phenotypes
				snpIDs_set1 = set([item[0] for item in value1])
				snpIDs_set2 = set([item[0] for item in value2])
				sharedSNPs = list(set.intersection(snpIDs_set1, snpIDs_set2))

				# Write this line to the output file
				if(len(sharedSNPs) > 0):
					#edgeMapOutput.write(key1 + "\t" + key2 + "\t" + str(getLdPrunedCount(snpLdsetMap, sharedSNPs)) + "\t" + str(sharedSNPs) + "\n")
					edgeMapOutput.write(key1 + "\t" + key2 + "\t" + str(len(sharedSNPs)) + "\t" + str(sharedSNPs) + "\n")

		print("Processed phenotype " + key1 + ", " + str(i) + " out of " + str(len(phenotypeSnpMap_sorted.keys())) + " phenotypes for the edge map")

print("Finished creating edge map.")

print("All done!")
